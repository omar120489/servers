{"version":3,"file":"attribution-BSL5szA1.js","sources":["../../node_modules/uuid/dist/stringify.js","../../node_modules/uuid/dist/rng.js","../../node_modules/uuid/dist/native.js","../../node_modules/uuid/dist/v4.js","../../src/utils/attribution.ts"],"sourcesContent":["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","/**\n * Attribution Tracking Utility\n * \n * Captures UTM parameters and platform advertising IDs from URL query parameters,\n * generates unique tracking identifiers (UTI) per session, and provides attribution\n * data for lead creation with one-time send guard.\n * \n * Design:\n * - UTI stored in sessionStorage (new UTI per browser session/tab)\n * - Attribution sent only with first lead of each session\n * - Hybrid update: preserve existing UTMs if URL has none, update if present\n */\n\nimport { v4 as uuidv4 } from 'uuid';\n\nconst STORAGE_KEYS = {\n  UTI: 'traffic_crm_uti',\n  ATTRIBUTION: 'traffic_crm_attribution',\n  SENT_FLAG: 'traffic_crm_attribution_sent'\n} as const;\n\nexport interface AttributionData {\n  uti: string;\n  utm: {\n    source?: string;\n    medium?: string;\n    campaign?: string;\n    term?: string;\n    content?: string;\n  };\n  platform: {\n    ad_id?: string;\n    adset_id?: string;\n    campaign_id?: string;\n  };\n  captured_at: string;\n}\n\n/**\n * Generate a new Unique Tracking Identifier (v4 UUID)\n */\nfunction generateUTI(): string {\n  return uuidv4();\n}\n\n/**\n * Get or create UTI from sessionStorage\n */\nfunction getOrCreateUTI(): string {\n  let uti = sessionStorage.getItem(STORAGE_KEYS.UTI);\n  if (!uti) {\n    uti = generateUTI();\n    sessionStorage.setItem(STORAGE_KEYS.UTI, uti);\n  }\n  return uti;\n}\n\n/**\n * Parse UTM and platform parameters from current URL\n */\nfunction parseURLParameters(): Partial<AttributionData> {\n  const params = new URLSearchParams(globalThis.location.search);\n  \n  const utm = {\n    source: params.get('utm_source') || undefined,\n    medium: params.get('utm_medium') || undefined,\n    campaign: params.get('utm_campaign') || undefined,\n    term: params.get('utm_term') || undefined,\n    content: params.get('utm_content') || undefined\n  };\n  \n  const platform = {\n    ad_id: params.get('ad_id') || undefined,\n    adset_id: params.get('adset_id') || undefined,\n    campaign_id: params.get('campaign_id') || undefined\n  };\n  \n  // Only return objects with at least one defined value\n  const hasUtm = Object.values(utm).some(v => v !== undefined);\n  const hasPlatform = Object.values(platform).some(v => v !== undefined);\n  \n  return {\n    ...(hasUtm && { utm }),\n    ...(hasPlatform && { platform })\n  };\n}\n\n/**\n * Parse and store attribution data from URL\n * Implements hybrid update logic:\n * - If URL has new UTMs/platform IDs, update stored attribution\n * - If URL has no params, preserve existing attribution\n */\nexport function parseAttribution(): AttributionData {\n  const uti = getOrCreateUTI();\n  const urlParams = parseURLParameters();\n  \n  // Try to get existing attribution\n  const existingData = sessionStorage.getItem(STORAGE_KEYS.ATTRIBUTION);\n  let existing: AttributionData | null = null;\n  \n  try {\n    if (existingData) {\n      existing = JSON.parse(existingData);\n    }\n  } catch (error) {\n    console.warn('[Attribution] Failed to parse existing attribution:', error);\n  }\n  \n  // Hybrid update logic\n  const hasNewParams = urlParams.utm || urlParams.platform;\n  \n  const attribution: AttributionData = {\n    uti,\n    utm: {\n      source: urlParams.utm?.source ?? existing?.utm?.source,\n      medium: urlParams.utm?.medium ?? existing?.utm?.medium,\n      campaign: urlParams.utm?.campaign ?? existing?.utm?.campaign,\n      term: urlParams.utm?.term ?? existing?.utm?.term,\n      content: urlParams.utm?.content ?? existing?.utm?.content\n    },\n    platform: {\n      ad_id: urlParams.platform?.ad_id ?? existing?.platform?.ad_id,\n      adset_id: urlParams.platform?.adset_id ?? existing?.platform?.adset_id,\n      campaign_id: urlParams.platform?.campaign_id ?? existing?.platform?.campaign_id\n    },\n    captured_at: hasNewParams ? new Date().toISOString() : (existing?.captured_at || new Date().toISOString())\n  };\n  \n  // Store updated attribution\n  sessionStorage.setItem(STORAGE_KEYS.ATTRIBUTION, JSON.stringify(attribution));\n  \n  return attribution;\n}\n\n/**\n * Get attribution payload for lead creation\n * Returns null if attribution has already been sent this session\n * One-time send guard using sessionStorage flag\n */\nexport function getAttributionPayload(): AttributionData | null {\n  const hasSent = sessionStorage.getItem(STORAGE_KEYS.SENT_FLAG) === 'true';\n  \n  if (hasSent) {\n    return null;\n  }\n  \n  const data = sessionStorage.getItem(STORAGE_KEYS.ATTRIBUTION);\n  if (!data) {\n    return null;\n  }\n  \n  try {\n    return JSON.parse(data);\n  } catch (error) {\n    console.error('[Attribution] Failed to parse attribution payload:', error);\n    return null;\n  }\n}\n\n/**\n * Mark attribution as sent to prevent duplicate sends\n * Should be called after successful lead creation\n */\nexport function markAttributionSent(): void {\n  sessionStorage.setItem(STORAGE_KEYS.SENT_FLAG, 'true');\n}\n\n/**\n * Clear attribution data (useful for testing)\n */\nexport function clearAttribution(): void {\n  sessionStorage.removeItem(STORAGE_KEYS.UTI);\n  sessionStorage.removeItem(STORAGE_KEYS.ATTRIBUTION);\n  sessionStorage.removeItem(STORAGE_KEYS.SENT_FLAG);\n}\n\n/**\n * Check if attribution has been sent this session\n */\nexport function hasAttributionBeenSent(): boolean {\n  return sessionStorage.getItem(STORAGE_KEYS.SENT_FLAG) === 'true';\n}\n\n"],"names":["byteToHex","i","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","_v4","options","buf","rnds","v4","STORAGE_KEYS","generateUTI","uuidv4","getOrCreateUTI","uti","parseURLParameters","params","utm","platform","hasUtm","v","hasPlatform","parseAttribution","urlParams","existingData","existing","error","hasNewParams","attribution","getAttributionPayload","data","markAttributionSent"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}