{"version":3,"file":"index-BjfUBotL.js","sources":["../../node_modules/@mui/x-charts/esm/hooks/useBarSeries.js","../../node_modules/@mui/x-charts/esm/hooks/animation/useAnimateBar.js","../../node_modules/@mui/x-charts/esm/hooks/animation/useAnimateBarLabel.js","../../node_modules/@mui/x-charts/esm/BarChart/barElementClasses.js","../../node_modules/@mui/x-charts/esm/BarChart/AnimatedBarElement.js","../../node_modules/@mui/x-charts/esm/hooks/useIsItemFocused.js","../../node_modules/@mui/x-charts/esm/BarChart/BarElement.js","../../node_modules/@mui/x-charts/esm/BarChart/BarClipPath.js","../../node_modules/@mui/x-charts/esm/BarChart/BarLabel/barLabelClasses.js","../../node_modules/@mui/x-charts/esm/BarChart/BarLabel/getBarLabel.js","../../node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabel.js","../../node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelItem.js","../../node_modules/@mui/x-charts/esm/BarChart/barClasses.js","../../node_modules/@mui/x-charts/esm/BarChart/BarLabel/BarLabelPlot.js","../../node_modules/@mui/x-charts/esm/BarChart/checkScaleErrors.js","../../node_modules/@mui/x-charts/esm/BarChart/useBarPlotData.js","../../node_modules/@mui/x-charts/esm/BarChart/BarPlot.js","../../node_modules/@mui/x-charts/esm/BarChart/BarChart.plugins.js","../../node_modules/@mui/x-charts/esm/BarChart/useBarChartProps.js","../../node_modules/@mui/x-charts/esm/BarChart/BarChart.js"],"sourcesContent":["'use client';\n\nimport { createSeriesSelectorsOfType, createAllSeriesSelectorOfType } from \"../internals/createSeriesSelectorOfType.js\";\nconst useSelectorSeries = createSeriesSelectorsOfType('bar');\nconst useSelectorSeriesContext = createAllSeriesSelectorOfType('bar');\n\n/**\n * Get access to the internal state of bar series.\n *\n * @param {SeriesId} seriesId The id of the series to get.\n * @returns {UseBarSeriesReturnValue} the bar series\n */\n\n/**\n * Get access to the internal state of bar series.\n *\n * When called without arguments, it returns all bar series.\n *\n * @returns {UseBarSeriesReturnValue[]} the bar series\n */\n\n/**\n * Get access to the internal state of bar series.\n *\n * @param {SeriesId[]} seriesIds The ids of the series to get. Order is preserved.\n * @returns {UseBarSeriesReturnValue[]} the bar series\n */\n\nexport function useBarSeries(seriesIds) {\n  return useSelectorSeries(seriesIds);\n}\n\n/**\n * Get access to the internal state of bar series.\n * The returned object contains:\n * - series: a mapping from ids to series attributes.\n * - seriesOrder: the array of series ids.\n * - stackingGroups: the array of stacking groups. Each group contains the series ids stacked and the strategy to use.\n * @returns the bar series\n */\nexport function useBarSeriesContext() {\n  return useSelectorSeriesContext();\n}","import { interpolateNumber } from '@mui/x-charts-vendor/d3-interpolate';\nimport { useAnimate } from \"./useAnimate.js\";\nfunction barPropsInterpolator(from, to) {\n  const interpolateX = interpolateNumber(from.x, to.x);\n  const interpolateY = interpolateNumber(from.y, to.y);\n  const interpolateWidth = interpolateNumber(from.width, to.width);\n  const interpolateHeight = interpolateNumber(from.height, to.height);\n  return t => {\n    return {\n      x: interpolateX(t),\n      y: interpolateY(t),\n      width: interpolateWidth(t),\n      height: interpolateHeight(t)\n    };\n  };\n}\n\n/**\n * Animates a bar from the start of the axis (x-axis for vertical layout, y-axis for horizontal layout) to its\n * final position.\n *\n * The props object also accepts a `ref` which will be merged with the ref returned from this hook. This means you can\n * pass the ref returned by this hook to the `path` element and the `ref` provided as argument will also be called.\n */\nexport function useAnimateBar(props) {\n  const initialProps = {\n    x: props.layout === 'vertical' ? props.x : props.xOrigin,\n    y: props.layout === 'vertical' ? props.yOrigin : props.y,\n    width: props.layout === 'vertical' ? props.width : 0,\n    height: props.layout === 'vertical' ? 0 : props.height\n  };\n  return useAnimate({\n    x: props.x,\n    y: props.y,\n    width: props.width,\n    height: props.height\n  }, {\n    createInterpolator: barPropsInterpolator,\n    applyProps(element, animatedProps) {\n      element.setAttribute('x', animatedProps.x.toString());\n      element.setAttribute('y', animatedProps.y.toString());\n      element.setAttribute('width', animatedProps.width.toString());\n      element.setAttribute('height', animatedProps.height.toString());\n    },\n    transformProps: p => p,\n    initialProps,\n    skip: props.skipAnimation,\n    ref: props.ref\n  });\n}","import { interpolateNumber } from '@mui/x-charts-vendor/d3-interpolate';\nimport { useAnimate } from \"./useAnimate.js\";\nfunction barLabelPropsInterpolator(from, to) {\n  const interpolateX = interpolateNumber(from.x, to.x);\n  const interpolateY = interpolateNumber(from.y, to.y);\n  const interpolateWidth = interpolateNumber(from.width, to.width);\n  const interpolateHeight = interpolateNumber(from.height, to.height);\n  return t => {\n    return {\n      x: interpolateX(t),\n      y: interpolateY(t),\n      width: interpolateWidth(t),\n      height: interpolateHeight(t)\n    };\n  };\n}\n\n/**\n * Animates a bar label from the start of the axis (x-axis for vertical layout, y-axis for horizontal layout) to the\n * center of the bar it belongs to.\n * The label is horizontally centered within the bar when the layout is vertical, and vertically centered for laid out\n * horizontally.\n *\n * The props object also accepts a `ref` which will be merged with the ref returned from this hook. This means you can\n * pass the ref returned by this hook to the `path` element and the `ref` provided as argument will also be called.\n */\nexport function useAnimateBarLabel(props) {\n  const initialProps = {\n    x: props.layout === 'vertical' ? props.x + props.width / 2 : props.xOrigin,\n    y: props.layout === 'vertical' ? props.yOrigin : props.y + props.height / 2,\n    width: props.width,\n    height: props.height\n  };\n  const currentProps = {\n    x: props.x + props.width / 2,\n    y: props.y + props.height / 2,\n    width: props.width,\n    height: props.height\n  };\n  return useAnimate(currentProps, {\n    createInterpolator: barLabelPropsInterpolator,\n    transformProps: p => p,\n    applyProps(element, animatedProps) {\n      element.setAttribute('x', animatedProps.x.toString());\n      element.setAttribute('y', animatedProps.y.toString());\n      element.setAttribute('width', animatedProps.width.toString());\n      element.setAttribute('height', animatedProps.height.toString());\n    },\n    initialProps,\n    skip: props.skipAnimation,\n    ref: props.ref\n  });\n}","import generateUtilityClass from '@mui/utils/generateUtilityClass';\nimport composeClasses from '@mui/utils/composeClasses';\nimport generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nexport function getBarElementUtilityClass(slot) {\n  return generateUtilityClass('MuiBarElement', slot);\n}\nexport const barElementClasses = generateUtilityClasses('MuiBarElement', ['root', 'highlighted', 'faded', 'series']);\nexport const useUtilityClasses = ownerState => {\n  const {\n    classes,\n    id,\n    isHighlighted,\n    isFaded\n  } = ownerState;\n  const slots = {\n    root: ['root', `series-${id}`, isHighlighted && 'highlighted', isFaded && 'faded']\n  };\n  return composeClasses(slots, getBarElementUtilityClass, classes);\n};","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"ownerState\", \"skipAnimation\", \"id\", \"dataIndex\", \"xOrigin\", \"yOrigin\"];\nimport * as React from 'react';\nimport { useAnimateBar } from \"../hooks/animation/useAnimateBar.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport function AnimatedBarElement(props) {\n  const {\n      ownerState\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const animatedProps = useAnimateBar(props);\n  return /*#__PURE__*/_jsx(\"rect\", _extends({}, other, {\n    filter: ownerState.isHighlighted ? 'brightness(120%)' : undefined,\n    opacity: ownerState.isFaded ? 0.3 : 1,\n    \"data-highlighted\": ownerState.isHighlighted || undefined,\n    \"data-faded\": ownerState.isFaded || undefined\n  }, animatedProps));\n}","'use client';\n\nimport { useFocusedItem } from \"./useFocusedItem.js\";\n/**\n * A hook to check if an item has the focus.\n *\n * If you need to process multiple points, use the `useIsItemFocusedGetter` hook instead.\n *\n * @param {FocusedItemData} item is the item to check\n * @returns {boolean} the focus state\n */\nexport function useIsItemFocused(item) {\n  const focusedItem = useFocusedItem();\n  return focusedItem !== null && focusedItem.seriesType === item.seriesType && focusedItem.seriesId === item.seriesId && focusedItem.dataIndex === item.dataIndex;\n}","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"id\", \"dataIndex\", \"classes\", \"color\", \"slots\", \"slotProps\", \"style\", \"onClick\", \"skipAnimation\", \"layout\", \"x\", \"xOrigin\", \"y\", \"yOrigin\", \"width\", \"height\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport useSlotProps from '@mui/utils/useSlotProps';\nimport { useUtilityClasses } from \"./barElementClasses.js\";\nimport { useInteractionItemProps } from \"../hooks/useInteractionItemProps.js\";\nimport { useItemHighlighted } from \"../hooks/useItemHighlighted.js\";\nimport { AnimatedBarElement } from \"./AnimatedBarElement.js\";\nimport { useIsItemFocused } from \"../hooks/useIsItemFocused.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction BarElement(props) {\n  const {\n      id,\n      dataIndex,\n      classes: innerClasses,\n      color,\n      slots,\n      slotProps,\n      style,\n      onClick,\n      skipAnimation,\n      layout,\n      x,\n      xOrigin,\n      y,\n      yOrigin,\n      width,\n      height\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const interactionProps = useInteractionItemProps({\n    type: 'bar',\n    seriesId: id,\n    dataIndex\n  });\n  const {\n    isFaded,\n    isHighlighted\n  } = useItemHighlighted({\n    seriesId: id,\n    dataIndex\n  });\n  const isFocused = useIsItemFocused({\n    seriesType: 'bar',\n    seriesId: id,\n    dataIndex\n  });\n  const ownerState = {\n    id,\n    dataIndex,\n    classes: innerClasses,\n    color,\n    isFaded,\n    isHighlighted,\n    isFocused\n  };\n  const classes = useUtilityClasses(ownerState);\n  const Bar = slots?.bar ?? AnimatedBarElement;\n  const barProps = useSlotProps({\n    elementType: Bar,\n    externalSlotProps: slotProps?.bar,\n    externalForwardedProps: other,\n    additionalProps: _extends({}, interactionProps, {\n      id,\n      dataIndex,\n      color,\n      x,\n      xOrigin,\n      y,\n      yOrigin,\n      width,\n      height,\n      style,\n      onClick,\n      cursor: onClick ? 'pointer' : 'unset',\n      stroke: 'none',\n      fill: color,\n      skipAnimation,\n      layout,\n      'data-focused': isFocused || undefined\n    }),\n    className: classes.root,\n    ownerState\n  });\n  return /*#__PURE__*/_jsx(Bar, _extends({}, barProps));\n}\nprocess.env.NODE_ENV !== \"production\" ? BarElement.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  classes: PropTypes.object,\n  dataIndex: PropTypes.number.isRequired,\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  layout: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,\n  skipAnimation: PropTypes.bool.isRequired,\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object,\n  xOrigin: PropTypes.number.isRequired,\n  yOrigin: PropTypes.number.isRequired\n} : void 0;\nexport { BarElement };","'use client';\n\nimport * as React from 'react';\nimport { interpolateNumber } from '@mui/x-charts-vendor/d3-interpolate';\nimport { useAnimate } from \"../hooks/animation/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction barClipPathPropsInterpolator(from, to) {\n  const interpolateX = interpolateNumber(from.x, to.x);\n  const interpolateY = interpolateNumber(from.y, to.y);\n  const interpolateWidth = interpolateNumber(from.width, to.width);\n  const interpolateHeight = interpolateNumber(from.height, to.height);\n  const interpolateBorderRadius = interpolateNumber(from.borderRadius, to.borderRadius);\n  return t => {\n    return {\n      x: interpolateX(t),\n      y: interpolateY(t),\n      width: interpolateWidth(t),\n      height: interpolateHeight(t),\n      borderRadius: interpolateBorderRadius(t)\n    };\n  };\n}\nexport function useAnimateBarClipPath(props) {\n  const initialProps = {\n    x: props.layout === 'vertical' ? props.x : props.xOrigin,\n    y: props.layout === 'vertical' ? props.yOrigin : props.y,\n    width: props.layout === 'vertical' ? props.width : 0,\n    height: props.layout === 'vertical' ? 0 : props.height,\n    borderRadius: props.borderRadius\n  };\n  return useAnimate({\n    x: props.x,\n    y: props.y,\n    width: props.width,\n    height: props.height,\n    borderRadius: props.borderRadius\n  }, {\n    createInterpolator: barClipPathPropsInterpolator,\n    transformProps: p => ({\n      d: generateClipPath(props.hasNegative, props.hasPositive, props.layout, p.x, p.y, p.width, p.height, props.xOrigin, props.yOrigin, p.borderRadius)\n    }),\n    applyProps(element, {\n      d\n    }) {\n      if (d) {\n        element.setAttribute('d', d);\n      }\n    },\n    initialProps,\n    skip: props.skipAnimation,\n    ref: props.ref\n  });\n}\n/**\n * @ignore - internal component.\n */\nfunction BarClipPath(props) {\n  const {\n    maskId,\n    x,\n    y,\n    width,\n    height,\n    skipAnimation\n  } = props;\n  const {\n    ref,\n    d\n  } = useAnimateBarClipPath({\n    layout: props.layout ?? 'vertical',\n    hasNegative: props.hasNegative,\n    hasPositive: props.hasPositive,\n    xOrigin: props.xOrigin,\n    yOrigin: props.yOrigin,\n    x,\n    y,\n    width,\n    height,\n    borderRadius: props.borderRadius ?? 0,\n    skipAnimation\n  });\n  if (!props.borderRadius || props.borderRadius <= 0) {\n    return null;\n  }\n  return /*#__PURE__*/_jsx(\"clipPath\", {\n    id: maskId,\n    children: /*#__PURE__*/_jsx(\"path\", {\n      ref: ref,\n      d: d\n    })\n  });\n}\nfunction generateClipPath(hasNegative, hasPositive, layout, x, y, width, height, xOrigin, yOrigin, borderRadius) {\n  if (layout === 'vertical') {\n    if (hasPositive && hasNegative) {\n      const bR = Math.min(borderRadius, width / 2, height / 2);\n      return `M${x},${y + height / 2} v${-(height / 2 - bR)} a${bR},${bR} 0 0 1 ${bR},${-bR} h${width - bR * 2} a${bR},${bR} 0 0 1 ${bR},${bR} v${height - 2 * bR} a${bR},${bR} 0 0 1 ${-bR},${bR} h${-(width - bR * 2)} a${bR},${bR} 0 0 1 ${-bR},${-bR} v${-(height / 2 - bR)}`;\n    }\n    const bR = Math.min(borderRadius, width / 2);\n    if (hasPositive) {\n      return `M${x},${Math.max(yOrigin, y + bR)} v${Math.min(0, -(yOrigin - y - bR))} a${bR},${bR} 0 0 1 ${bR},${-bR} h${width - bR * 2} a${bR},${bR} 0 0 1 ${bR},${bR} v${Math.max(0, yOrigin - y - bR)} Z`;\n    }\n    if (hasNegative) {\n      return `M${x},${Math.min(yOrigin, y + height - bR)} v${Math.max(0, height - bR)} a${bR},${bR} 0 0 0 ${bR},${bR} h${width - bR * 2} a${bR},${bR} 0 0 0 ${bR},${-bR} v${-Math.max(0, height - bR)} Z`;\n    }\n  }\n  if (layout === 'horizontal') {\n    if (hasPositive && hasNegative) {\n      const bR = Math.min(borderRadius, width / 2, height / 2);\n      return `M${x + width / 2},${y} h${width / 2 - bR} a${bR},${bR} 0 0 1 ${bR},${bR} v${height - bR * 2} a${bR},${bR} 0 0 1 ${-bR},${bR} h${-(width - 2 * bR)} a${bR},${bR} 0 0 1 ${-bR},${-bR} v${-(height - bR * 2)} a${bR},${bR} 0 0 1 ${bR},${-bR} h${width / 2 - bR}`;\n    }\n    const bR = Math.min(borderRadius, height / 2);\n    if (hasPositive) {\n      return `M${Math.min(xOrigin, x - bR)},${y} h${width} a${bR},${bR} 0 0 1 ${bR},${bR} v${height - bR * 2} a${bR},${bR} 0 0 1 ${-bR},${bR} h${-width} Z`;\n    }\n    if (hasNegative) {\n      return `M${Math.max(xOrigin, x + width + bR)},${y} h${-width} a${bR},${bR} 0 0 0 ${-bR},${bR} v${height - bR * 2} a${bR},${bR} 0 0 0 ${bR},${bR} h${width} Z`;\n    }\n  }\n  return undefined;\n}\nexport { BarClipPath };","import generateUtilityClass from '@mui/utils/generateUtilityClass';\nimport generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport composeClasses from '@mui/utils/composeClasses';\nexport function getBarLabelUtilityClass(slot) {\n  return generateUtilityClass('MuiBarLabel', slot);\n}\nexport const barLabelClasses = generateUtilityClasses('MuiBarLabel', ['root', 'highlighted', 'faded', 'animate']);\nexport const useUtilityClasses = ownerState => {\n  const {\n    classes,\n    seriesId,\n    isFaded,\n    isHighlighted,\n    skipAnimation\n  } = ownerState;\n  const slots = {\n    root: ['root', `series-${seriesId}`, isHighlighted && 'highlighted', isFaded && 'faded', !skipAnimation && 'animate']\n  };\n  return composeClasses(slots, getBarLabelUtilityClass, classes);\n};","export const getBarLabel = options => {\n  const {\n    barLabel,\n    value,\n    dataIndex,\n    seriesId,\n    height,\n    width\n  } = options;\n  if (barLabel === 'value') {\n    // We don't want to show the label if the value is 0\n    return value ? value?.toString() : null;\n  }\n  return barLabel({\n    seriesId,\n    dataIndex,\n    value\n  }, {\n    bar: {\n      height,\n      width\n    }\n  });\n};","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"seriesId\", \"dataIndex\", \"color\", \"isFaded\", \"isHighlighted\", \"classes\", \"skipAnimation\", \"layout\", \"xOrigin\", \"yOrigin\"];\nimport * as React from 'react';\nimport { styled, useThemeProps } from '@mui/material/styles';\nimport PropTypes from 'prop-types';\nimport { useAnimateBarLabel } from \"../../hooks/animation/useAnimateBarLabel.js\";\nimport { barLabelClasses } from \"./barLabelClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const BarLabelComponent = styled('text', {\n  name: 'MuiBarLabel',\n  slot: 'Root',\n  overridesResolver: (_, styles) => [{\n    [`&.${barLabelClasses.faded}`]: styles.faded\n  }, {\n    [`&.${barLabelClasses.highlighted}`]: styles.highlighted\n  }, styles.root]\n})(({\n  theme\n}) => _extends({}, theme?.typography?.body2, {\n  stroke: 'none',\n  fill: (theme.vars || theme)?.palette?.text?.primary,\n  transition: 'opacity 0.2s ease-in, fill 0.2s ease-in',\n  textAnchor: 'middle',\n  dominantBaseline: 'central',\n  pointerEvents: 'none',\n  opacity: 1,\n  [`&.${barLabelClasses.faded}`]: {\n    opacity: 0.3\n  }\n}));\nfunction BarLabel(inProps) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiBarLabel'\n  });\n  const otherProps = _objectWithoutPropertiesLoose(props, _excluded);\n  const animatedProps = useAnimateBarLabel(props);\n  return /*#__PURE__*/_jsx(BarLabelComponent, _extends({}, otherProps, animatedProps));\n}\nprocess.env.NODE_ENV !== \"production\" ? BarLabel.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  classes: PropTypes.object,\n  dataIndex: PropTypes.number.isRequired,\n  /**\n   * Height of the bar this label belongs to.\n   */\n  height: PropTypes.number.isRequired,\n  isFaded: PropTypes.bool.isRequired,\n  isHighlighted: PropTypes.bool.isRequired,\n  layout: PropTypes.oneOf(['horizontal', 'vertical']).isRequired,\n  seriesId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  skipAnimation: PropTypes.bool.isRequired,\n  /**\n   * Width of the bar this label belongs to.\n   */\n  width: PropTypes.number.isRequired,\n  /**\n   * Position in the x-axis of the bar this label belongs to.\n   */\n  x: PropTypes.number.isRequired,\n  /**\n   * The x-coordinate of the stack this bar label belongs to.\n   */\n  xOrigin: PropTypes.number.isRequired,\n  /**\n   * Position in the y-axis of the bar this label belongs to.\n   */\n  y: PropTypes.number.isRequired,\n  /**\n   * The y-coordinate of the stack this bar label belongs to.\n   */\n  yOrigin: PropTypes.number.isRequired\n} : void 0;\nexport { BarLabel };","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"seriesId\", \"classes\", \"color\", \"dataIndex\", \"barLabel\", \"slots\", \"slotProps\", \"xOrigin\", \"yOrigin\", \"x\", \"y\", \"width\", \"height\", \"value\", \"skipAnimation\", \"layout\"],\n  _excluded2 = [\"ownerState\"];\nimport * as React from 'react';\nimport useSlotProps from '@mui/utils/useSlotProps';\nimport PropTypes from 'prop-types';\nimport { useUtilityClasses } from \"./barLabelClasses.js\";\nimport { getBarLabel } from \"./getBarLabel.js\";\nimport { BarLabel } from \"./BarLabel.js\";\nimport { useItemHighlighted } from \"../../hooks/useItemHighlighted.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * @ignore - internal component.\n */\nfunction BarLabelItem(props) {\n  const {\n      seriesId,\n      classes: innerClasses,\n      color,\n      dataIndex,\n      barLabel,\n      slots,\n      slotProps,\n      xOrigin,\n      yOrigin,\n      x,\n      y,\n      width,\n      height,\n      value,\n      skipAnimation,\n      layout\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const {\n    isFaded,\n    isHighlighted\n  } = useItemHighlighted({\n    seriesId,\n    dataIndex\n  });\n  const ownerState = {\n    seriesId,\n    classes: innerClasses,\n    color,\n    isFaded,\n    isHighlighted,\n    dataIndex,\n    skipAnimation,\n    layout\n  };\n  const classes = useUtilityClasses(ownerState);\n  const Component = slots?.barLabel ?? BarLabel;\n  const _useSlotProps = useSlotProps({\n      elementType: Component,\n      externalSlotProps: slotProps?.barLabel,\n      additionalProps: _extends({}, other, {\n        xOrigin,\n        yOrigin,\n        x,\n        y,\n        width,\n        height,\n        className: classes.root\n      }),\n      ownerState\n    }),\n    {\n      ownerState: barLabelOwnerState\n    } = _useSlotProps,\n    barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded2);\n  if (!barLabel) {\n    return null;\n  }\n  const formattedLabelText = getBarLabel({\n    barLabel,\n    value,\n    dataIndex,\n    seriesId,\n    height,\n    width\n  });\n  if (!formattedLabelText) {\n    return null;\n  }\n  return /*#__PURE__*/_jsx(Component, _extends({}, barLabelProps, barLabelOwnerState, {\n    children: formattedLabelText\n  }));\n}\nprocess.env.NODE_ENV !== \"production\" ? BarLabelItem.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * If provided, the function will be used to format the label of the bar.\n   * It can be set to 'value' to display the current value.\n   * @param {BarItem} item The item to format.\n   * @param {BarLabelContext} context data about the bar.\n   * @returns {string} The formatted label.\n   */\n  barLabel: PropTypes.oneOfType([PropTypes.oneOf(['value']), PropTypes.func]),\n  classes: PropTypes.object,\n  color: PropTypes.string.isRequired,\n  dataIndex: PropTypes.number.isRequired,\n  /**\n   * The height of the bar.\n   */\n  height: PropTypes.number.isRequired,\n  seriesId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object,\n  /**\n   * The value of the data point.\n   */\n  value: PropTypes.number,\n  /**\n   * The width of the bar.\n   */\n  width: PropTypes.number.isRequired\n} : void 0;\nexport { BarLabelItem };","import generateUtilityClass from '@mui/utils/generateUtilityClass';\nimport composeClasses from '@mui/utils/composeClasses';\nimport generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nexport function getBarUtilityClass(slot) {\n  return generateUtilityClass('MuiBar', slot);\n}\nexport const barClasses = generateUtilityClasses('MuiBar', ['root', 'series', 'seriesLabels']);\nexport const useUtilityClasses = classes => {\n  const slots = {\n    root: ['root'],\n    series: ['series'],\n    seriesLabels: ['seriesLabels']\n  };\n  return composeClasses(slots, getBarUtilityClass, classes);\n};","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"bars\", \"skipAnimation\"];\nimport * as React from 'react';\nimport { BarLabelItem } from \"./BarLabelItem.js\";\nimport { useUtilityClasses } from \"../barClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * @ignore - internal component.\n */\nfunction BarLabelPlot(props) {\n  const {\n      bars,\n      skipAnimation\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const classes = useUtilityClasses();\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: bars.flatMap(({\n      seriesId,\n      data\n    }) => /*#__PURE__*/_jsx(\"g\", {\n      className: classes.seriesLabels,\n      \"data-series\": seriesId,\n      children: data.map(({\n        xOrigin,\n        yOrigin,\n        x,\n        y,\n        dataIndex,\n        color,\n        value,\n        width,\n        height,\n        layout\n      }) => /*#__PURE__*/_jsx(BarLabelItem, _extends({\n        seriesId: seriesId,\n        dataIndex: dataIndex,\n        value: value,\n        color: color,\n        xOrigin: xOrigin,\n        yOrigin: yOrigin,\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        skipAnimation: skipAnimation ?? false,\n        layout: layout ?? 'vertical'\n      }, other), dataIndex))\n    }, seriesId))\n  });\n}\nexport { BarLabelPlot };","import { warnOnce } from '@mui/x-internals/warning';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from \"../constants/index.js\";\nimport { isBandScaleConfig, isPointScaleConfig } from \"../models/axis.js\";\nconst getAxisMessage = (axisDirection, axisId) => {\n  const axisName = `${axisDirection}-axis`;\n  const axisIdName = `${axisDirection}Axis`;\n  const axisDefaultKey = axisDirection === 'x' ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;\n  return axisId === axisDefaultKey ? `The first \\`${axisIdName}\\`` : `The ${axisName} with id \"${axisId}\"`;\n};\nexport function checkScaleErrors(verticalLayout, seriesId, series, xAxisId, xAxis, yAxisId, yAxis) {\n  const xAxisConfig = xAxis[xAxisId];\n  const yAxisConfig = yAxis[yAxisId];\n  const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;\n  const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;\n  const discreteAxisId = verticalLayout ? xAxisId : yAxisId;\n  const continuousAxisId = verticalLayout ? yAxisId : xAxisId;\n  const discreteAxisDirection = verticalLayout ? 'x' : 'y';\n  const continuousAxisDirection = verticalLayout ? 'y' : 'x';\n  if (!isBandScaleConfig(discreteAxisConfig)) {\n    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type \"band\" to display the bar series of id \"${seriesId}\".`);\n  }\n  if (discreteAxisConfig.data === undefined) {\n    throw new Error(`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);\n  }\n  if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {\n    throw new Error(`MUI X Charts: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id \"${seriesId}\".`);\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (discreteAxisConfig.data.length < series.stackedData.length) {\n      warnOnce([`MUI X Charts: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} has less data (${discreteAxisConfig.data.length} values) than the bar series of id \"${seriesId}\" (${series.stackedData.length} values).`, 'The axis data should have at least the same length than the series using it.'], 'error');\n    }\n  }\n}","import getColor from \"./seriesConfig/getColor.js\";\nimport { useChartId, useXAxes, useYAxes } from \"../hooks/index.js\";\nimport { checkScaleErrors } from \"./checkScaleErrors.js\";\nimport { useBarSeriesContext } from \"../hooks/useBarSeries.js\";\nexport function useBarPlotData(drawingArea, xAxes, yAxes) {\n  const seriesData = useBarSeriesContext() ?? {\n    series: {},\n    stackingGroups: [],\n    seriesOrder: []\n  };\n  const defaultXAxisId = useXAxes().xAxisIds[0];\n  const defaultYAxisId = useYAxes().yAxisIds[0];\n  const chartId = useChartId();\n  const {\n    series,\n    stackingGroups\n  } = seriesData;\n  const masks = {};\n  const data = stackingGroups.flatMap(({\n    ids: seriesIds\n  }, groupIndex) => {\n    const xMin = drawingArea.left;\n    const xMax = drawingArea.left + drawingArea.width;\n    const yMin = drawingArea.top;\n    const yMax = drawingArea.top + drawingArea.height;\n    return seriesIds.map(seriesId => {\n      const xAxisId = series[seriesId].xAxisId ?? defaultXAxisId;\n      const yAxisId = series[seriesId].yAxisId ?? defaultYAxisId;\n      const xAxisConfig = xAxes[xAxisId];\n      const yAxisConfig = yAxes[yAxisId];\n      const verticalLayout = series[seriesId].layout === 'vertical';\n      const reverse = (verticalLayout ? yAxisConfig.reverse : xAxisConfig.reverse) ?? false;\n      checkScaleErrors(verticalLayout, seriesId, series[seriesId], xAxisId, xAxes, yAxisId, yAxes);\n      const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;\n      const xScale = xAxisConfig.scale;\n      const yScale = yAxisConfig.scale;\n      const colorGetter = getColor(series[seriesId], xAxes[xAxisId], yAxes[yAxisId]);\n      const bandWidth = baseScaleConfig.scale.bandwidth();\n      const {\n        barWidth,\n        offset\n      } = getBandSize({\n        bandWidth,\n        numberOfGroups: stackingGroups.length,\n        gapRatio: baseScaleConfig.barGapRatio\n      });\n      const barOffset = groupIndex * (barWidth + offset);\n      const {\n        stackedData,\n        data: currentSeriesData,\n        layout,\n        minBarSize\n      } = series[seriesId];\n      const seriesDataPoints = [];\n      for (let dataIndex = 0; dataIndex < baseScaleConfig.data.length; dataIndex += 1) {\n        const baseValue = baseScaleConfig.data[dataIndex];\n        const seriesValue = currentSeriesData[dataIndex];\n        if (seriesValue == null) {\n          continue;\n        }\n        const values = stackedData[dataIndex];\n        const valueCoordinates = values.map(v => verticalLayout ? yScale(v) : xScale(v));\n        const minValueCoord = Math.round(Math.min(...valueCoordinates));\n        const maxValueCoord = Math.round(Math.max(...valueCoordinates));\n        const stackId = series[seriesId].stack;\n        const barSize = seriesValue === 0 ? 0 : Math.max(minBarSize, maxValueCoord - minValueCoord);\n        const startCoordinate = shouldInvertStartCoordinate(verticalLayout, seriesValue, reverse) ? maxValueCoord - barSize : minValueCoord;\n        const result = {\n          seriesId,\n          dataIndex,\n          layout,\n          x: verticalLayout ? xScale(baseValue) + barOffset : startCoordinate,\n          y: verticalLayout ? startCoordinate : yScale(baseValue) + barOffset,\n          xOrigin: xScale(0) ?? 0,\n          yOrigin: yScale(0) ?? 0,\n          height: verticalLayout ? barSize : barWidth,\n          width: verticalLayout ? barWidth : barSize,\n          color: colorGetter(dataIndex),\n          value: currentSeriesData[dataIndex],\n          maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`\n        };\n        if (result.x > xMax || result.x + result.width < xMin || result.y > yMax || result.y + result.height < yMin) {\n          continue;\n        }\n        if (!masks[result.maskId]) {\n          masks[result.maskId] = {\n            id: result.maskId,\n            width: 0,\n            height: 0,\n            hasNegative: false,\n            hasPositive: false,\n            layout: result.layout,\n            xOrigin: xScale(0),\n            yOrigin: yScale(0),\n            x: 0,\n            y: 0\n          };\n        }\n        const mask = masks[result.maskId];\n        mask.width = result.layout === 'vertical' ? result.width : mask.width + result.width;\n        mask.height = result.layout === 'vertical' ? mask.height + result.height : result.height;\n        mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);\n        mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);\n        const value = result.value ?? 0;\n        mask.hasNegative = mask.hasNegative || (reverse ? value > 0 : value < 0);\n        mask.hasPositive = mask.hasPositive || (reverse ? value < 0 : value > 0);\n        seriesDataPoints.push(result);\n      }\n      return {\n        seriesId,\n        data: seriesDataPoints\n      };\n    });\n  });\n  return {\n    completedData: data,\n    masksData: Object.values(masks)\n  };\n}\n\n/**\n * Solution of the equations\n * W = barWidth * N + offset * (N-1)\n * offset / (offset + barWidth) = r\n * @param bandWidth The width available to place bars.\n * @param numberOfGroups The number of bars to place in that space.\n * @param gapRatio The ratio of the gap between bars over the bar width.\n * @returns The bar width and the offset between bars.\n */\nfunction getBandSize({\n  bandWidth: W,\n  numberOfGroups: N,\n  gapRatio: r\n}) {\n  if (r === 0) {\n    return {\n      barWidth: W / N,\n      offset: 0\n    };\n  }\n  const barWidth = W / (N + (N - 1) * r);\n  const offset = r * barWidth;\n  return {\n    barWidth,\n    offset\n  };\n}\nfunction shouldInvertStartCoordinate(verticalLayout, baseValue, reverse) {\n  const isVerticalAndPositive = verticalLayout && baseValue > 0;\n  const isHorizontalAndNegative = !verticalLayout && baseValue < 0;\n  const invertStartCoordinate = isVerticalAndPositive || isHorizontalAndNegative;\n  return reverse ? !invertStartCoordinate : invertStartCoordinate;\n}","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"skipAnimation\", \"onItemClick\", \"borderRadius\", \"barLabel\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { styled } from '@mui/material/styles';\nimport { barElementClasses } from \"./barElementClasses.js\";\nimport { BarElement } from \"./BarElement.js\";\nimport { useDrawingArea, useXAxes, useYAxes } from \"../hooks/index.js\";\nimport { BarClipPath } from \"./BarClipPath.js\";\nimport { BarLabelPlot } from \"./BarLabel/BarLabelPlot.js\";\nimport { useSkipAnimation } from \"../hooks/useSkipAnimation.js\";\nimport { useInternalIsZoomInteracting } from \"../internals/plugins/featurePlugins/useChartCartesianAxis/useInternalIsZoomInteracting.js\";\nimport { useBarPlotData } from \"./useBarPlotData.js\";\nimport { useUtilityClasses } from \"./barClasses.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst BarPlotRoot = styled('g', {\n  name: 'MuiBarPlot',\n  slot: 'Root'\n})({\n  [`& .${barElementClasses.root}`]: {\n    transition: 'opacity 0.2s ease-in, fill 0.2s ease-in'\n  }\n});\n\n/**\n * Demos:\n *\n * - [Bars](https://mui.com/x/react-charts/bars/)\n * - [Bar demonstration](https://mui.com/x/react-charts/bar-demo/)\n * - [Stacking](https://mui.com/x/react-charts/stacking/)\n *\n * API:\n *\n * - [BarPlot API](https://mui.com/x/api/charts/bar-plot/)\n */\nfunction BarPlot(props) {\n  const {\n      skipAnimation: inSkipAnimation,\n      onItemClick,\n      borderRadius,\n      barLabel\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const isZoomInteracting = useInternalIsZoomInteracting();\n  const skipAnimation = useSkipAnimation(isZoomInteracting || inSkipAnimation);\n  const {\n    xAxis: xAxes\n  } = useXAxes();\n  const {\n    yAxis: yAxes\n  } = useYAxes();\n  const {\n    completedData,\n    masksData\n  } = useBarPlotData(useDrawingArea(), xAxes, yAxes);\n  const withoutBorderRadius = !borderRadius || borderRadius <= 0;\n  const classes = useUtilityClasses();\n  return /*#__PURE__*/_jsxs(BarPlotRoot, {\n    className: classes.root,\n    children: [!withoutBorderRadius && masksData.map(({\n      id,\n      x,\n      y,\n      xOrigin,\n      yOrigin,\n      width,\n      height,\n      hasPositive,\n      hasNegative,\n      layout\n    }) => {\n      return /*#__PURE__*/_jsx(BarClipPath, {\n        maskId: id,\n        borderRadius: borderRadius,\n        hasNegative: hasNegative,\n        hasPositive: hasPositive,\n        layout: layout,\n        x: x,\n        y: y,\n        xOrigin: xOrigin,\n        yOrigin: yOrigin,\n        width: width,\n        height: height,\n        skipAnimation: skipAnimation ?? false\n      }, id);\n    }), completedData.map(({\n      seriesId,\n      data\n    }) => {\n      return /*#__PURE__*/_jsx(\"g\", {\n        \"data-series\": seriesId,\n        className: classes.series,\n        children: data.map(({\n          dataIndex,\n          color,\n          maskId,\n          layout,\n          x,\n          xOrigin,\n          y,\n          yOrigin,\n          width,\n          height\n        }) => {\n          const barElement = /*#__PURE__*/_jsx(BarElement, _extends({\n            id: seriesId,\n            dataIndex: dataIndex,\n            color: color,\n            skipAnimation: skipAnimation ?? false,\n            layout: layout ?? 'vertical',\n            x: x,\n            xOrigin: xOrigin,\n            y: y,\n            yOrigin: yOrigin,\n            width: width,\n            height: height\n          }, other, {\n            onClick: onItemClick && (event => {\n              onItemClick(event, {\n                type: 'bar',\n                seriesId,\n                dataIndex\n              });\n            })\n          }), dataIndex);\n          if (withoutBorderRadius) {\n            return barElement;\n          }\n          return /*#__PURE__*/_jsx(\"g\", {\n            clipPath: `url(#${maskId})`,\n            children: barElement\n          }, dataIndex);\n        })\n      }, seriesId);\n    }), barLabel && /*#__PURE__*/_jsx(BarLabelPlot, _extends({\n      bars: completedData,\n      skipAnimation: skipAnimation,\n      barLabel: barLabel\n    }, other))]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? BarPlot.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * If provided, the function will be used to format the label of the bar.\n   * It can be set to 'value' to display the current value.\n   * @param {BarItem} item The item to format.\n   * @param {BarLabelContext} context data about the bar.\n   * @returns {string} The formatted label.\n   */\n  barLabel: PropTypes.oneOfType([PropTypes.oneOf(['value']), PropTypes.func]),\n  /**\n   * Defines the border radius of the bar element.\n   */\n  borderRadius: PropTypes.number,\n  /**\n   * Callback fired when a bar item is clicked.\n   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.\n   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * If `true`, animations are skipped.\n   * @default undefined\n   */\n  skipAnimation: PropTypes.bool,\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object\n} : void 0;\nexport { BarPlot };","import { useChartZAxis } from \"../internals/plugins/featurePlugins/useChartZAxis/index.js\";\nimport { useChartCartesianAxis } from \"../internals/plugins/featurePlugins/useChartCartesianAxis/index.js\";\nimport { useChartInteraction } from \"../internals/plugins/featurePlugins/useChartInteraction/index.js\";\nimport { useChartHighlight } from \"../internals/plugins/featurePlugins/useChartHighlight/index.js\";\nimport { useChartKeyboardNavigation } from \"../internals/plugins/featurePlugins/useChartKeyboardNavigation/index.js\";\nexport const BAR_CHART_PLUGINS = [useChartZAxis, useChartCartesianAxis, useChartInteraction, useChartHighlight, useChartKeyboardNavigation];","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"xAxis\", \"yAxis\", \"series\", \"width\", \"height\", \"margin\", \"colors\", \"dataset\", \"sx\", \"axisHighlight\", \"grid\", \"children\", \"slots\", \"slotProps\", \"skipAnimation\", \"loading\", \"layout\", \"onItemClick\", \"highlightedItem\", \"onHighlightChange\", \"borderRadius\", \"barLabel\", \"className\", \"hideLegend\", \"showToolbar\"];\nimport * as React from 'react';\nimport useId from '@mui/utils/useId';\nimport { DEFAULT_X_AXIS_KEY, DEFAULT_Y_AXIS_KEY } from \"../constants/index.js\";\nimport { BAR_CHART_PLUGINS } from \"./BarChart.plugins.js\";\n\n/**\n * A helper function that extracts BarChartProps from the input props\n * and returns an object with props for the children components of BarChart.\n *\n * @param props The input props for BarChart\n * @returns An object with props for the children components of BarChart\n */\nexport const useBarChartProps = props => {\n  const {\n      xAxis,\n      yAxis,\n      series,\n      width,\n      height,\n      margin,\n      colors,\n      dataset,\n      sx,\n      axisHighlight,\n      grid,\n      children,\n      slots,\n      slotProps,\n      skipAnimation,\n      loading,\n      layout,\n      onItemClick,\n      highlightedItem,\n      onHighlightChange,\n      borderRadius,\n      barLabel,\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const id = useId();\n  const clipPathId = `${id}-clip-path`;\n  const hasHorizontalSeries = layout === 'horizontal' || layout === undefined && series.some(item => item.layout === 'horizontal');\n  const defaultBandXAxis = React.useMemo(() => [{\n    id: DEFAULT_X_AXIS_KEY,\n    scaleType: 'band',\n    data: Array.from({\n      length: Math.max(...series.map(s => (s.data ?? dataset ?? []).length))\n    }, (_, index) => index)\n  }], [dataset, series]);\n  const defaultBandYAxis = React.useMemo(() => [{\n    id: DEFAULT_Y_AXIS_KEY,\n    scaleType: 'band',\n    data: Array.from({\n      length: Math.max(...series.map(s => (s.data ?? dataset ?? []).length))\n    }, (_, index) => index)\n  }], [dataset, series]);\n  const seriesWithDefault = React.useMemo(() => series.map(s => _extends({\n    type: 'bar'\n  }, s, {\n    layout: hasHorizontalSeries ? 'horizontal' : 'vertical'\n  })), [hasHorizontalSeries, series]);\n  const defaultXAxis = hasHorizontalSeries ? undefined : defaultBandXAxis;\n  const processedXAxis = React.useMemo(() => {\n    if (!xAxis) {\n      return defaultXAxis;\n    }\n    return hasHorizontalSeries ? xAxis : xAxis.map(axis => _extends({\n      scaleType: 'band'\n    }, axis));\n  }, [defaultXAxis, hasHorizontalSeries, xAxis]);\n  const defaultYAxis = hasHorizontalSeries ? defaultBandYAxis : undefined;\n  const processedYAxis = React.useMemo(() => {\n    if (!yAxis) {\n      return defaultYAxis;\n    }\n    return hasHorizontalSeries ? yAxis.map(axis => _extends({\n      scaleType: 'band'\n    }, axis)) : yAxis;\n  }, [defaultYAxis, hasHorizontalSeries, yAxis]);\n  const chartContainerProps = _extends({}, other, {\n    series: seriesWithDefault,\n    width,\n    height,\n    margin,\n    colors,\n    dataset,\n    xAxis: processedXAxis,\n    yAxis: processedYAxis,\n    highlightedItem,\n    onHighlightChange,\n    disableAxisListener: slotProps?.tooltip?.trigger !== 'axis' && axisHighlight?.x === 'none' && axisHighlight?.y === 'none',\n    className,\n    skipAnimation,\n    plugins: BAR_CHART_PLUGINS\n  });\n  const barPlotProps = {\n    onItemClick,\n    slots,\n    slotProps,\n    borderRadius,\n    barLabel\n  };\n  const gridProps = {\n    vertical: grid?.vertical,\n    horizontal: grid?.horizontal\n  };\n  const clipPathGroupProps = {\n    clipPath: `url(#${clipPathId})`\n  };\n  const clipPathProps = {\n    id: clipPathId\n  };\n  const overlayProps = {\n    slots,\n    slotProps,\n    loading\n  };\n  const chartsAxisProps = {\n    slots,\n    slotProps\n  };\n  const axisHighlightProps = _extends({}, hasHorizontalSeries ? {\n    y: 'band'\n  } : {\n    x: 'band'\n  }, axisHighlight);\n  const legendProps = {\n    slots,\n    slotProps\n  };\n  const chartsWrapperProps = {\n    sx,\n    legendPosition: props.slotProps?.legend?.position,\n    legendDirection: props.slotProps?.legend?.direction,\n    hideLegend: props.hideLegend ?? false\n  };\n  return {\n    chartsWrapperProps,\n    chartContainerProps,\n    barPlotProps,\n    gridProps,\n    clipPathProps,\n    clipPathGroupProps,\n    overlayProps,\n    chartsAxisProps,\n    axisHighlightProps,\n    legendProps,\n    children\n  };\n};","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { useThemeProps } from '@mui/material/styles';\nimport { BarPlot } from \"./BarPlot.js\";\nimport { ChartsAxis } from \"../ChartsAxis/index.js\";\nimport { ChartsTooltip } from \"../ChartsTooltip/index.js\";\nimport { ChartsLegend } from \"../ChartsLegend/index.js\";\nimport { ChartsAxisHighlight } from \"../ChartsAxisHighlight/index.js\";\nimport { ChartsClipPath } from \"../ChartsClipPath/index.js\";\nimport { ChartsGrid } from \"../ChartsGrid/index.js\";\nimport { ChartsOverlay } from \"../ChartsOverlay/ChartsOverlay.js\";\nimport { useBarChartProps } from \"./useBarChartProps.js\";\nimport { ChartDataProvider } from \"../ChartDataProvider/index.js\";\nimport { ChartsSurface } from \"../ChartsSurface/index.js\";\nimport { useChartContainerProps } from \"../ChartContainer/useChartContainerProps.js\";\nimport { ChartsWrapper } from \"../ChartsWrapper/index.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n/**\n * Demos:\n *\n * - [Bars](https://mui.com/x/react-charts/bars/)\n * - [Bar demonstration](https://mui.com/x/react-charts/bar-demo/)\n * - [Stacking](https://mui.com/x/react-charts/stacking/)\n *\n * API:\n *\n * - [BarChart API](https://mui.com/x/api/charts/bar-chart/)\n */\nconst BarChart = /*#__PURE__*/React.forwardRef(function BarChart(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiBarChart'\n  });\n  const {\n    chartsWrapperProps,\n    chartContainerProps,\n    barPlotProps,\n    gridProps,\n    clipPathProps,\n    clipPathGroupProps,\n    overlayProps,\n    chartsAxisProps,\n    axisHighlightProps,\n    legendProps,\n    children\n  } = useBarChartProps(props);\n  const {\n    chartDataProviderProps,\n    chartsSurfaceProps\n  } = useChartContainerProps(chartContainerProps, ref);\n  const Tooltip = props.slots?.tooltip ?? ChartsTooltip;\n  const Toolbar = props.slots?.toolbar;\n  return /*#__PURE__*/_jsx(ChartDataProvider, _extends({}, chartDataProviderProps, {\n    children: /*#__PURE__*/_jsxs(ChartsWrapper, _extends({}, chartsWrapperProps, {\n      children: [props.showToolbar && Toolbar ? /*#__PURE__*/_jsx(Toolbar, _extends({}, props.slotProps?.toolbar)) : null, !props.hideLegend && /*#__PURE__*/_jsx(ChartsLegend, _extends({}, legendProps)), /*#__PURE__*/_jsxs(ChartsSurface, _extends({}, chartsSurfaceProps, {\n        children: [/*#__PURE__*/_jsx(ChartsGrid, _extends({}, gridProps)), /*#__PURE__*/_jsxs(\"g\", _extends({}, clipPathGroupProps, {\n          children: [/*#__PURE__*/_jsx(BarPlot, _extends({}, barPlotProps)), /*#__PURE__*/_jsx(ChartsOverlay, _extends({}, overlayProps)), /*#__PURE__*/_jsx(ChartsAxisHighlight, _extends({}, axisHighlightProps))]\n        })), /*#__PURE__*/_jsx(ChartsAxis, _extends({}, chartsAxisProps)), /*#__PURE__*/_jsx(ChartsClipPath, _extends({}, clipPathProps)), children]\n      })), !props.loading && /*#__PURE__*/_jsx(Tooltip, _extends({}, props.slotProps?.tooltip))]\n    }))\n  }));\n});\nif (process.env.NODE_ENV !== \"production\") BarChart.displayName = \"BarChart\";\nprocess.env.NODE_ENV !== \"production\" ? BarChart.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"pnpm proptypes\"  |\n  // ----------------------------------------------------------------------\n  apiRef: PropTypes.shape({\n    current: PropTypes.object\n  }),\n  /**\n   * The configuration of axes highlight.\n   * Default is set to 'band' in the bar direction.\n   * Depends on `layout` prop.\n   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.\n   */\n  axisHighlight: PropTypes.shape({\n    x: PropTypes.oneOf(['band', 'line', 'none']),\n    y: PropTypes.oneOf(['band', 'line', 'none'])\n  }),\n  /**\n   * If provided, the function will be used to format the label of the bar.\n   * It can be set to 'value' to display the current value.\n   * @param {BarItem} item The item to format.\n   * @param {BarLabelContext} context data about the bar.\n   * @returns {string} The formatted label.\n   */\n  barLabel: PropTypes.oneOfType([PropTypes.oneOf(['value']), PropTypes.func]),\n  /**\n   * Defines the border radius of the bar element.\n   */\n  borderRadius: PropTypes.number,\n  children: PropTypes.node,\n  className: PropTypes.string,\n  /**\n   * Color palette used to colorize multiple series.\n   * @default rainbowSurgePalette\n   */\n  colors: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.func]),\n  /**\n   * An array of objects that can be used to populate series and axes data using their `dataKey` property.\n   */\n  dataset: PropTypes.arrayOf(PropTypes.object),\n  desc: PropTypes.string,\n  /**\n   * If `true`, the charts will not listen to the mouse move event.\n   * It might break interactive features, but will improve performance.\n   * @default false\n   */\n  disableAxisListener: PropTypes.bool,\n  enableKeyboardNavigation: PropTypes.bool,\n  /**\n   * Option to display a cartesian grid in the background.\n   */\n  grid: PropTypes.shape({\n    horizontal: PropTypes.bool,\n    vertical: PropTypes.bool\n  }),\n  /**\n   * The height of the chart in px. If not defined, it takes the height of the parent element.\n   */\n  height: PropTypes.number,\n  /**\n   * If `true`, the legend is not rendered.\n   */\n  hideLegend: PropTypes.bool,\n  /**\n   * The controlled axis highlight.\n   * Identified by the axis id, and data index.\n   */\n  highlightedAxis: PropTypes.arrayOf(PropTypes.shape({\n    axisId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n    dataIndex: PropTypes.number.isRequired\n  })),\n  /**\n   * The highlighted item.\n   * Used when the highlight is controlled.\n   */\n  highlightedItem: PropTypes.shape({\n    dataIndex: PropTypes.number,\n    seriesId: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired\n  }),\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n  /**\n   * The direction of the bar elements.\n   * @default 'vertical'\n   */\n  layout: PropTypes.oneOf(['horizontal', 'vertical']),\n  /**\n   * If `true`, a loading overlay is displayed.\n   * @default false\n   */\n  loading: PropTypes.bool,\n  /**\n   * Localized text for chart components.\n   */\n  localeText: PropTypes.object,\n  /**\n   * The margin between the SVG and the drawing area.\n   * It's used for leaving some space for extra information such as the x- and y-axis or legend.\n   *\n   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.\n   */\n  margin: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    bottom: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    top: PropTypes.number\n  })]),\n  /**\n   * The function called for onClick events.\n   * The second argument contains information about all line/bar elements at the current mouse position.\n   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.\n   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.\n   */\n  onAxisClick: PropTypes.func,\n  /**\n   * The callback fired when the highlighted item changes.\n   *\n   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.\n   */\n  onHighlightChange: PropTypes.func,\n  /**\n   * The function called when the pointer position corresponds to a new axis data item.\n   * This update can either be caused by a pointer movement, or an axis update.\n   * In case of multiple axes, the function is called if at least one axis is updated.\n   * The argument contains the identifier for all axes with a `data` property.\n   * @param {AxisItemIdentifier[]} axisItems The array of axes item identifiers.\n   */\n  onHighlightedAxisChange: PropTypes.func,\n  /**\n   * Callback fired when a bar item is clicked.\n   * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.\n   * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.\n   */\n  onItemClick: PropTypes.func,\n  /**\n   * The series to display in the bar chart.\n   * An array of [[BarSeries]] objects.\n   */\n  series: PropTypes.arrayOf(PropTypes.object).isRequired,\n  /**\n   * If true, shows the default chart toolbar.\n   * @default false\n   */\n  showToolbar: PropTypes.bool,\n  /**\n   * If `true`, animations are skipped.\n   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.\n   */\n  skipAnimation: PropTypes.bool,\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object,\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  theme: PropTypes.oneOf(['dark', 'light']),\n  title: PropTypes.string,\n  /**\n   * The width of the chart in px. If not defined, it takes the width of the parent element.\n   */\n  width: PropTypes.number,\n  /**\n   * The configuration of the x-axes.\n   * If not provided, a default axis config is used.\n   * An array of [[AxisConfig]] objects.\n   */\n  xAxis: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    barGapRatio: PropTypes.number,\n    categoryGapRatio: PropTypes.number,\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      type: PropTypes.oneOf(['ordinal']).isRequired,\n      unknownColor: PropTypes.string,\n      values: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number, PropTypes.string]).isRequired)\n    }), PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    groups: PropTypes.arrayOf(PropTypes.shape({\n      getValue: PropTypes.func.isRequired,\n      tickLabelStyle: PropTypes.object,\n      tickSize: PropTypes.number\n    })),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['band']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      type: PropTypes.oneOf(['ordinal']).isRequired,\n      unknownColor: PropTypes.string,\n      values: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number, PropTypes.string]).isRequired)\n    }), PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    groups: PropTypes.arrayOf(PropTypes.shape({\n      getValue: PropTypes.func.isRequired,\n      tickLabelStyle: PropTypes.object,\n      tickSize: PropTypes.number\n    })),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['point']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['log']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    constant: PropTypes.number,\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['symlog']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['pow']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['sqrt']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    min: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['time']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    min: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['utc']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['x']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    height: PropTypes.number,\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['bottom', 'none', 'top']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['linear']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelMinGap: PropTypes.number,\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func\n  })]).isRequired),\n  /**\n   * The configuration of the y-axes.\n   * If not provided, a default axis config is used.\n   * An array of [[AxisConfig]] objects.\n   */\n  yAxis: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    barGapRatio: PropTypes.number,\n    categoryGapRatio: PropTypes.number,\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      type: PropTypes.oneOf(['ordinal']).isRequired,\n      unknownColor: PropTypes.string,\n      values: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number, PropTypes.string]).isRequired)\n    }), PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    groups: PropTypes.arrayOf(PropTypes.shape({\n      getValue: PropTypes.func.isRequired,\n      tickLabelStyle: PropTypes.object,\n      tickSize: PropTypes.number\n    })),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['band']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      type: PropTypes.oneOf(['ordinal']).isRequired,\n      unknownColor: PropTypes.string,\n      values: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number, PropTypes.string]).isRequired)\n    }), PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    groups: PropTypes.arrayOf(PropTypes.shape({\n      getValue: PropTypes.func.isRequired,\n      tickLabelStyle: PropTypes.object,\n      tickSize: PropTypes.number\n    })),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['point']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['log']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    constant: PropTypes.number,\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['symlog']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['pow']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['sqrt']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    min: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['time']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    min: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      valueOf: PropTypes.func.isRequired\n    })]),\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['utc']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  }), PropTypes.shape({\n    axis: PropTypes.oneOf(['y']),\n    classes: PropTypes.object,\n    colorMap: PropTypes.oneOfType([PropTypes.shape({\n      color: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string.isRequired), PropTypes.func]).isRequired,\n      max: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      min: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),\n      type: PropTypes.oneOf(['continuous']).isRequired\n    }), PropTypes.shape({\n      colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n      thresholds: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired).isRequired,\n      type: PropTypes.oneOf(['piecewise']).isRequired\n    })]),\n    data: PropTypes.array,\n    dataKey: PropTypes.string,\n    disableLine: PropTypes.bool,\n    disableTicks: PropTypes.bool,\n    domainLimit: PropTypes.oneOfType([PropTypes.oneOf(['nice', 'strict']), PropTypes.func]),\n    hideTooltip: PropTypes.bool,\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n    ignoreTooltip: PropTypes.bool,\n    label: PropTypes.string,\n    labelStyle: PropTypes.object,\n    max: PropTypes.number,\n    min: PropTypes.number,\n    offset: PropTypes.number,\n    position: PropTypes.oneOf(['left', 'none', 'right']),\n    reverse: PropTypes.bool,\n    scaleType: PropTypes.oneOf(['linear']),\n    slotProps: PropTypes.object,\n    slots: PropTypes.object,\n    sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n    tickInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.array, PropTypes.func]),\n    tickLabelInterval: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.func]),\n    tickLabelPlacement: PropTypes.oneOf(['middle', 'tick']),\n    tickLabelStyle: PropTypes.object,\n    tickMaxStep: PropTypes.number,\n    tickMinStep: PropTypes.number,\n    tickNumber: PropTypes.number,\n    tickPlacement: PropTypes.oneOf(['end', 'extremities', 'middle', 'start']),\n    tickSize: PropTypes.number,\n    valueFormatter: PropTypes.func,\n    width: PropTypes.number\n  })]).isRequired)\n} : void 0;\nexport { BarChart };"],"names":["createSeriesSelectorsOfType","useSelectorSeriesContext","createAllSeriesSelectorOfType","useBarSeriesContext","barPropsInterpolator","from","to","interpolateX","interpolateNumber","interpolateY","interpolateWidth","interpolateHeight","t","useAnimateBar","props","initialProps","useAnimate","element","animatedProps","p","barLabelPropsInterpolator","useAnimateBarLabel","currentProps","getBarElementUtilityClass","slot","generateUtilityClass","barElementClasses","generateUtilityClasses","useUtilityClasses","ownerState","classes","id","isHighlighted","isFaded","slots","composeClasses","_excluded","importShared","AnimatedBarElement","other","_objectWithoutPropertiesLoose","_jsx","_extends","useIsItemFocused","item","focusedItem","useFocusedItem","BarElement","dataIndex","innerClasses","color","slotProps","style","onClick","skipAnimation","layout","x","xOrigin","y","yOrigin","width","height","interactionProps","useInteractionItemProps","useItemHighlighted","isFocused","Bar","barProps","useSlotProps","barClipPathPropsInterpolator","interpolateBorderRadius","useAnimateBarClipPath","generateClipPath","d","BarClipPath","maskId","ref","hasNegative","hasPositive","borderRadius","bR","getBarLabelUtilityClass","barLabelClasses","seriesId","getBarLabel","options","barLabel","value","BarLabelComponent","styled","_","styles","theme","BarLabel","inProps","useThemeProps","otherProps","_excluded2","BarLabelItem","Component","_useSlotProps","barLabelOwnerState","barLabelProps","formattedLabelText","getBarUtilityClass","barClasses","React","BarLabelPlot","bars","data","getAxisMessage","axisDirection","axisId","axisName","axisIdName","DEFAULT_X_AXIS_KEY","DEFAULT_Y_AXIS_KEY","checkScaleErrors","verticalLayout","series","xAxisId","xAxis","yAxisId","yAxis","xAxisConfig","yAxisConfig","discreteAxisConfig","continuousAxisConfig","discreteAxisId","continuousAxisId","discreteAxisDirection","continuousAxisDirection","isBandScaleConfig","isPointScaleConfig","useBarPlotData","drawingArea","xAxes","yAxes","seriesData","defaultXAxisId","useXAxes","defaultYAxisId","useYAxes","chartId","useChartId","stackingGroups","masks","seriesIds","groupIndex","xMin","xMax","yMin","yMax","reverse","baseScaleConfig","xScale","yScale","colorGetter","getColor","bandWidth","barWidth","offset","getBandSize","barOffset","stackedData","currentSeriesData","minBarSize","seriesDataPoints","baseValue","seriesValue","valueCoordinates","v","minValueCoord","maxValueCoord","stackId","barSize","startCoordinate","shouldInvertStartCoordinate","result","mask","W","N","r","isVerticalAndPositive","isHorizontalAndNegative","invertStartCoordinate","BarPlotRoot","BarPlot","inSkipAnimation","onItemClick","isZoomInteracting","useInternalIsZoomInteracting","useSkipAnimation","completedData","masksData","useDrawingArea","withoutBorderRadius","barElement","event","BAR_CHART_PLUGINS","useChartZAxis","useChartCartesianAxis","useChartInteraction","useChartHighlight","useChartKeyboardNavigation","useBarChartProps","margin","colors","dataset","sx","axisHighlight","grid","children","loading","highlightedItem","onHighlightChange","className","clipPathId","useId","hasHorizontalSeries","defaultBandXAxis","s","index","defaultBandYAxis","seriesWithDefault","defaultXAxis","processedXAxis","axis","defaultYAxis","processedYAxis","chartContainerProps","barPlotProps","gridProps","clipPathGroupProps","clipPathProps","overlayProps","chartsAxisProps","axisHighlightProps","legendProps","BarChart","chartsWrapperProps","chartDataProviderProps","chartsSurfaceProps","useChartContainerProps","Tooltip","ChartsTooltip","Toolbar","ChartDataProvider","_jsxs","ChartsWrapper","ChartsLegend","ChartsSurface","ChartsGrid","ChartsOverlay","ChartsAxisHighlight","ChartsAxis","ChartsClipPath"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}